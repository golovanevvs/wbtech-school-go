# L1

- [L1.1 Встраивание структур](L1.1)

Дана структура `Human` (с произвольным набором полей и методов).

Реализовать встраивание методов в структуре `Action` от родительской структуры `Human` (аналог наследования).

Подсказка: используйте композицию (embedded struct), чтобы `Action` имел все методы `Human`.

- [L1.2 Конкурентное возведение в квадрат](L1.2)

Написать программу, которая конкурентно рассчитает значения квадратов чисел, взятых из массива [2,4,6,8,10], и выведет результаты в stdout.

Подсказка: запусти несколько горутин, каждая из которых возводит число в квадрат.

- [L1.3 Работа нескольких воркеров](L1.3)

Реализовать постоянную запись данных в канал (в главной горутине).

Реализовать набор из `N` воркеров, которые читают данные из этого канала и выводят их в stdout.

Программа должна принимать параметром количество воркеров и при старте создавать указанное число горутин-воркеров.

- [L1.4 Завершение по Ctrl+C](L1.4)

Программа должна корректно завершаться по нажатию `Ctrl+C` (`SIGINT`).

Выберите и обоснуйте способ завершения работы всех горутин-воркеров при получении сигнала прерывания.

Подсказка: можно использовать контекст (context.Context) или канал для оповещения о завершении.

- [L1.5 Таймаут на канал](L1.5)

Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала – читать эти значения. По истечении `N` секунд программа должна завершаться.

Подсказка: используйте `time.After` или таймер для ограничения времени работы.

- [L1.6 Остановка горутины](L1.6)

Реализовать все возможные способы остановки выполнения горутины.

Классические подходы: выход по условию, через канал уведомления, через контекст, прекращение работы `runtime.Goexit()` и др.

Продемонстрируйте каждый способ в отдельном фрагменте кода.

- [L1.7 Конкурентная запись в map](L1.7)

Реализовать безопасную для конкуренции запись данных в структуру `map`.

Подсказка: необходимость использования синхронизации (например, `sync.Mutex` или встроенная `concurrent-map`).

Проверьте работу кода на гонки (util `go run -race`).

- [L1.8 Установка бита в числе](L1.8)

Дана переменная типа `int64`. Разработать программу, которая устанавливает `i`-й бит этого числа в 1 или 0.

Пример: для числа 5 (0101₂) установка 1-го бита в 0 даст 4 (0100₂).

Подсказка: используйте битовые операции (|, &^).

- [L1.9 Конвейер чисел](L1.9)

Разработать конвейер чисел. Даны два канала: в первый пишутся числа `x` из массива, во второй – результат операции `x*2`. После этого данные из второго канала должны выводиться в stdout. То есть, организуйте конвейер из двух этапов с горутинами: генерация чисел и их обработка. Убедитесь, что чтение из второго канала корректно завершается.

- [L1.10 Группировка температур](L1.10)

Дана последовательность температурных колебаний: -25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить эти значения в группы с шагом 10 градусов.

Пример: -20:{-25.4, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20:{24.5}, 30:{32.5}.

Пояснение: диапазон -20 включает значения от -20 до -29.9, диапазон 10 – от 10 до 19.9, и т.д. Порядок в подмножествах не важен.

- [L1.11 Пересечение множеств](L1.11)

Реализовать пересечение двух неупорядоченных множеств (например, двух слайсов) — т.е. вывести элементы, присутствующие и в первом, и во втором.

Пример:
A = {1,2,3}
B = {2,3,4}
Пересечение = {2,3}

- [L1.12 Собственное множество строк](L1.12)

Имеется последовательность строк: ("cat", "cat", "dog", "cat", "tree"). Создать для неё собственное множество.

Ожидается: получить набор уникальных слов. Для примера, множество = {"cat", "dog", "tree"}.

- [L1.13 Обмен значениями без третьей переменной](L1.13)

Поменять местами два числа без использования временной переменной.

Подсказка: примените сложение/вычитание или XOR-обмен.

- [L1.14 Определение типа переменной в runtime](L1.14)

Разработать программу, которая в runtime способна определить тип переменной, переданной в неё (на вход подаётся interface{}). Типы, которые нужно распознавать: int, string, bool, chan (канал).

Подсказка: оператор типа switch v.(type) поможет в решении.

- [L1.15 Небольшой фрагмент кода — проблемы и решение](L1.15)

Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?

Приведите корректный пример реализации.

```go
var justString string

func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
```

Вопрос: что происходит с переменной justString?

- [L1.16 Быстрая сортировка (quicksort)](L1.16)

Реализовать алгоритм быстрой сортировки массива встроенными средствами языка. Можно использовать рекурсию.

Подсказка: напишите функцию `quickSort([]int) []int` которая сортирует срез целых чисел. Для выбора опорного элемента можно взять середину или первый элемент.

- [L1.17 Бинарный поиск](L1.17)

Реализовать алгоритм бинарного поиска встроенными методами языка. Функция должна принимать отсортированный слайс и искомый элемент, возвращать индекс элемента или -1, если элемент не найден.

Подсказка: можно реализовать рекурсивно или итеративно, используя цикл for.

- [L1.18 Конкурентный счетчик](L1.18)

Реализовать структуру-счётчик, которая будет инкрементироваться в конкурентной среде (т.е. из нескольких горутин). По завершению программы структура должна выводить итоговое значение счётчика.

Подсказка: вам понадобится механизм синхронизации, например, `sync.Mutex` или `sync/Atomic` для безопасного инкремента.

- [L1.19 Разворот строки](L1.19)

Разработать программу, которая переворачивает подаваемую на вход строку.

Например: при вводе строки «главрыба» вывод должен быть «абырвалг».

Учтите, что символы могут быть в Unicode (русские буквы, emoji и пр.), то есть просто iterating по байтам может не подойти — нужен срез рун ([]rune).

- [L1.20 Разворот слов в предложении](L1.20)

Разработать программу, которая переворачивает порядок слов в строке.

Пример: входная строка:

«snow dog sun», выход: «sun dog snow».

Считайте, что слова разделяются одиночным пробелом. Постарайтесь не использовать дополнительные срезы, а выполнять операцию «на месте».

- [L1.21 Паттерн «Адаптер»](L1.21)

Реализовать паттерн проектирования «Адаптер» на любом примере.

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой, несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

- [L1.22 Большие числа и операции](L1.22)

Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных `a`, `b`, значения которых > 2^20 (больше 1 миллион).

Комментарий: в Go тип int справится с такими числами, но обратите внимание на возможное переполнение для ещё больших значений. Для очень больших чисел можно использовать `math/big`.

- [L1.23 Удаление элемента слайса](L1.23)

Удалить i-ый элемент из слайса. Продемонстрируйте корректное удаление без утечки памяти.

Подсказка: можно сдвинуть хвост слайса на место удаляемого элемента (copy(slice[i:], slice[i+1:])) и уменьшить длину слайса на 1.

- [L1.24 Расстояние между точками](L1.24)

Разработать программу нахождения расстояния между двумя точками на плоскости. Точки представлены в виде структуры Point с инкапсулированными (приватными) полями `x`, `y` (типа `float64`) и конструктором. Расстояние рассчитывается по формуле между координатами двух точек.

Подсказка: используйте функцию-конструктор `NewPoint(x, y) Point` и метод `Distance(other Point) float64`.

- [L1.25 Своя функция Sleep](L1.25)

Реализовать собственную функцию `sleep(duration)` аналогично встроенной функции `time.Sleep`, которая приостанавливает выполнение текущей горутины.

Важно: в отличии от настоящей `time.Sleep`, ваша функция должна именно блокировать выполнение (например, через таймер или цикл), а не просто вызывать `time.Sleep` :) — это упражнение.

Можно использовать канал + горутину, или цикл на проверку времени (не лучший способ, но для обучения).

- [L1.26 Уникальные символы в строке](L1.26)

Разработать программу, которая проверяет, что все символы в строке встречаются один раз (т.е. строка состоит из уникальных символов).

Вывод: `true`, если все символы уникальны, `false`, если есть повторения. Проверка должна быть регистронезависимой, т.е. символы в разных регистрах считать одинаковыми.

Например: `"abcd" -> true`, `"abCdefAaf" -> false` (повторяются `a/A`), `"aabcd" -> false`.

Подумайте, какой структурой данных удобно воспользоваться для проверки условия.
