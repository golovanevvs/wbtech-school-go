# Load environment variables
ENV_FILE ?= .env
ifneq (,$(wildcard $(ENV_FILE)))
include $(ENV_FILE)
export
endif

# Project paths
POSTGRES_DIR = resources/postgres-replication
PGAUTO_DIR = resources/pg-auto-failover

.PHONY: help up down restart status logs setup check clean purge test backup monitor promote-slave1 promote-slave2 check-master check-lag pgauto-up pgauto-down pgauto-status pgauto-monitor clean-all

# Default target
help:
	@echo "PostgreSQL Replication Management"
	@echo "Using env file: $(ENV_FILE)"
	@echo ""
	@echo "Available commands:"
	@echo "  make up       - Start PostgreSQL cluster (master + 2 slaves)"
	@echo "  make down     - Stop PostgreSQL cluster"
	@echo "  make restart  - Restart PostgreSQL cluster"
	@echo "  make status   - Show replication status"
	@echo "  make logs     - Show logs from all containers"
	@echo "  make setup    - Setup replication (run after first start)"
	@echo "  make check    - Check replication health"
	@echo "  make clean    - Remove containers and networks"
	@echo "  make purge    - Remove containers, networks and volumes"
	@echo "  make test     - Test replication with sample data"
	@echo "  make backup   - Create backup from master"
	@echo "  make monitor  - Real-time replication monitoring"
	@echo "  make promote-slave1 - Promote slave1 to master (emergency)"
	@echo "  make promote-slave2 - Promote slave2 to master (emergency)"
	@echo "  make check-master - Check which node is master"
	@echo "  make check-lag - Check replication lag"
	@echo "  make pgauto-up - Start pg_auto_failover cluster"
	@echo "  make pgauto-down - Stop pg_auto_failover cluster"
	@echo "  make pgauto-status - Show pg_auto_failover status"
	@echo "  make pgauto-monitor - Real-time pg_auto_failover monitor"
	@echo "  make clean-all - Stop all clusters"

# Start the cluster
up:
	@echo "Starting PostgreSQL replication cluster..."
	@echo "Using env file: $(ENV_FILE)"
	docker-compose --env-file $(ENV_FILE) -f $(POSTGRES_DIR)/docker-compose-postgres.yml up -d
	@echo "Cluster started. Run 'make setup' to configure replication."

# Stop the cluster
down:
	@echo "Stopping PostgreSQL replication cluster..."
	docker-compose --env-file $(ENV_FILE) -f $(POSTGRES_DIR)/docker-compose-postgres.yml down

# Restart the cluster
restart: down up

# Show cluster status
status:
	@echo "=== Container Status ==="
	docker-compose --env-file $(ENV_FILE) -f $(POSTGRES_DIR)/docker-compose-postgres.yml ps
	@echo ""
	@echo "=== Master Replication Status ==="
	@docker exec postgres-master psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT client_addr, application_name, state, sync_state FROM pg_stat_replication;" 2>/dev/null || echo "Master not ready or no replicas connected"
	@echo ""
	@echo "=== Slave Status ==="
	@for slave in postgres-slave-1 postgres-slave-2; do \
		echo "$$slave:"; \
		docker exec $$slave psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT pg_is_in_recovery(), pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn();" 2>/dev/null || echo "  Not ready"; \
		echo ""; \
	done

# Show logs
logs:
	docker-compose --env-file $(ENV_FILE) -f $(POSTGRES_DIR)/docker-compose-postgres.yml logs -f

# Setup replication (run after first start)
setup:
	@echo "Setting up replication..."
	@cd $(POSTGRES_DIR) && bash setup-replication.sh ../$(ENV_FILE)
	@echo "Replication setup completed!"

# Check replication health
check:
	@echo "=== Replication Health Check ==="
	@echo "Master:"
	@docker exec postgres-master psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT count(*) as connected_slaves FROM pg_stat_replication;" 2>/dev/null || echo "Master not ready"
	@echo ""
	@echo "Slaves:"
	@for slave in postgres-slave-1 postgres-slave-2; do \
		echo "$$slave:"; \
		docker exec $$slave psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT now() - pg_last_xact_replay_timestamp() as replication_lag;" 2>/dev/null || echo "  Not ready"; \
	done

# Clean up containers and networks
clean:
	docker-compose --env-file $(ENV_FILE) -f $(POSTGRES_DIR)/docker-compose-postgres.yml down

# Remove everything including volumes
purge:
	@echo "WARNING: This will remove ALL data including databases!"
	@read -p "Are you sure? (y/N) " confirm; \
	if [ "$$confirm" = "y" ] || [ "$$confirm" = "Y" ]; then \
		docker-compose --env-file $(ENV_FILE) -f $(POSTGRES_DIR)/docker-compose-postgres.yml down -v; \
		echo "All data removed."; \
	else \
		echo "Purge cancelled."; \
	fi

# Test replication with sample data
test:
	@echo "Testing replication..."
	@echo "Creating test data on master..."
	@docker exec postgres-master psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c " \
		CREATE TABLE IF NOT EXISTS replication_test ( \
			id serial PRIMARY KEY, \
			data text, \
			created_at timestamptz DEFAULT now() \
		); \
		INSERT INTO replication_test (data) VALUES ('test_data_' || generate_series(1,5)); \
		SELECT count(*) as records_created FROM replication_test;" 2>/dev/null || echo "Master not ready"
	@echo ""
	@echo "Checking data on slaves:"
	@for slave in postgres-slave-1 postgres-slave-2; do \
		echo "$$slave:"; \
		docker exec $$slave psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT count(*) as records_replicated FROM replication_test;" 2>/dev/null || echo "  Not ready"; \
	done

# Create backup from master
backup:
	@echo "Creating backup from master..."
	@mkdir -p backups
	@docker exec postgres-master pg_dump -U ${POSTGRES_USER} -d ${POSTGRES_DB} -F c -f /tmp/backup.dump
	@docker cp postgres-master:/tmp/backup.dump backups/backup_$$(date +%Y%m%d_%H%M%S).dump
	@docker exec postgres-master rm -f /tmp/backup.dump
	@echo "Backup created in backups/ directory"

# Monitor replication in real-time
monitor:
	@echo "Starting real-time replication monitor (Ctrl+C to stop)..."
	@while true; do \
		clear; \
		echo "=== PostgreSQL Replication Monitor ==="; \
		echo "Time: $$(date)"; \
		echo ""; \
		echo "Master:"; \
		docker exec postgres-master psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT count(*) as active_slaves FROM pg_stat_replication;" 2>/dev/null || echo "  Master not ready"; \
		echo ""; \
		echo "Slaves:"; \
		for slave in postgres-slave-1 postgres-slave-2; do \
			echo "$$slave:"; \
			docker exec $$slave psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT pg_is_in_recovery(), now() - pg_last_xact_replay_timestamp() as lag;" 2>/dev/null | grep -v row | grep -v "-" | head -1 || echo "  Not ready"; \
		done; \
		sleep 5; \
	done

# Аварийное переключение - продвижение slave1 до мастера
promote-slave1:
	@echo "EMERGENCY: Promoting slave1 to master..."
	@docker exec postgres-slave-1 pg_ctl promote -D /var/lib/postgresql/data
	@echo "Slave1 promoted to master."
	@echo "Update your applications to connect to slave1 (port 5433) for writes."

# Аварийное переключение - продвижение slave2 до мастера  
promote-slave2:
	@echo "EMERGENCY: Promoting slave2 to master..."
	@docker exec postgres-slave-2 pg_ctl promote -D /var/lib/postgresql/data
	@echo "Slave2 promoted to master."
	@echo "Update your applications to connect to slave2 (port 5434) for writes."

# Проверка кто сейчас мастер
check-master:
	@echo "Checking which nodes are in recovery mode (slaves)..."
	@for node in postgres-master postgres-slave-1 postgres-slave-2; do \
		echo -n "$$node: "; \
		docker exec $$node psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -t -c "SELECT pg_is_in_recovery();" 2>/dev/null | tr -d '[:space:]' && echo " (in recovery = slave)" || echo " (not in recovery = master)"; \
	done

# Проверка lag репликации
check-lag:
	@echo "Replication lag check:"
	@for slave in postgres-slave-1 postgres-slave-2; do \
		echo -n "$$slave: "; \
		docker exec $$slave psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -t -c "SELECT now() - pg_last_xact_replay_timestamp() AS replication_lag;" 2>/dev/null | tr -d '[:space:]' || echo "unavailable"; \
	done

# ========================
# Auto Failover
# ========================

pgauto-up:
	@echo "Starting PG_AUTO_FAILOVER cluster..."
	@mkdir -p $(PGAUTO_DIR)
	@if [ ! -f "$(PGAUTO_DIR)/docker-compose-pgauto.yml" ]; then \
		echo "Creating pg_auto_failover compose file..."; \
		cat > $(PGAUTO_DIR)/docker-compose-pgauto.yml << 'EOF' ;\
services:\
  pgauto-monitor:\
    image: citusdata/pg_auto_failover:latest\
    container_name: pgauto-monitor\
    environment:\
      PG_AUTOCTL_DEBUG: 1\
    ports:\
      - "3000:3000"\
    command: >\
      pg_autoctl create monitor\
      --pgdata /var/lib/postgresql/monitor\
      --pgport 5432\
      --nodename pgauto-monitor\
      --hostname pgauto-monitor\
    networks:\
      - pgauto-network\
    volumes:\
      - pgauto-monitor-data:/var/lib/postgresql/monitor\
\
  pgauto-primary:\
    image: citusdata/pg_auto_failover:latest\
    container_name: pgauto-primary\
    environment:\
      PG_AUTOCTL_DEBUG: 1\
      PG_AUTOCTL_MONITOR: "postgres://autoctl_node@pgauto-monitor:5432/pg_auto_failover"\
    ports:\
      - "5432:5432"\
    command: >\
      pg_autoctl create postgres\
      --pgdata /var/lib/postgresql/primary\
      --pgport 5432\
      --nodename pgauto-primary\
      --hostname pgauto-primary\
      --name primary\
    depends_on:\
      - pgauto-monitor\
    networks:\
      - pgauto-network\
    volumes:\
      - pgauto-primary-data:/var/lib/postgresql/primary\
\
  pgauto-secondary:\
    image: citusdata/pg_auto_failover:latest\
    container_name: pgauto-secondary\
    environment:\
      PG_AUTOCTL_DEBUG: 1\
      PG_AUTOCTL_MONITOR: "postgres://autoctl_node@pgauto-monitor:5432/pg_auto_failover"\
    ports:\
      - "5433:5432"\
    command: >\
      pg_autoctl create postgres\
      --pgdata /var/lib/postgresql/secondary\
      --pgport 5432\
      --nodename pgauto-secondary\
      --hostname pgauto-secondary\
      --name secondary\
    depends_on:\
      - pgauto-monitor\
    networks:\
      - pgauto-network\
    volumes:\
      - pgauto-secondary-data:/var/lib/postgresql/secondary\
\
volumes:\
  pgauto-monitor-data:\
  pgauto-primary-data:\
  pgauto-secondary-data:\
\
networks:\
  pgauto-network:\
    driver: bridge\
EOF\
	fi
	docker-compose -f $(PGAUTO_DIR)/docker-compose-pgauto.yml up -d
	@echo "pg_auto_failover cluster starting..."
	@echo "Monitor UI: http://localhost:3000"
	@echo "Wait 30 seconds for full initialization"

pgauto-down:
	@echo "Stopping pg_auto_failover cluster..."
	docker-compose -f $(PGAUTO_DIR)/docker-compose-pgauto.yml down

pgauto-status:
	@echo "=== pg_auto_failover Status ==="
	@docker exec pgauto-monitor pg_autoctl show state 2>/dev/null || echo "pg_auto_failover not running"

pgauto-monitor:
	@echo "=== pg_auto_failover Real-time Monitor ==="
	@echo "Web UI: http://localhost:3000"
	@while true; do \
		clear; \
		echo "Time: $$(date)"; \
		docker exec pgauto-monitor pg_autoctl show state 2>/dev/null || echo "pg_auto_failover not available"; \
		sleep 5; \
	done

# Clean everything
clean-all:
	@echo "Cleaning ALL PostgreSQL clusters..."
	@$(MAKE) down
	@$(MAKE) pgauto-down
	@echo "All clusters stopped"