# L2

## [L2.1](L2.1)

Что выведет программа?

Объясните вывод программы.

```go
package main

import "fmt"

func main() {
  a := [5]int{76, 77, 78, 79, 80}
  var b []int = a[1:4]
  fmt.Println(b)
}
```

## [L2.2](L2.2)

Что выведет программа?

Объяснить порядок выполнения defer функций и итоговый вывод.

```go
package main

import "fmt"

func test() (x int) {
  defer func() {
    x++
  }()
  x = 1
  return
}

func anotherTest() int {
  var x int
  defer func() {
    x++
  }()
  x = 1
  return x
}

func main() {
  fmt.Println(test())
  fmt.Println(anotherTest())
}
```

## [L2.3](L2.3)

Что выведет программа?

Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
  "fmt"
  "os"
)

func Foo() error {
  var err *os.PathError = nil
  return err
}

func main() {
  err := Foo()
  fmt.Println(err)
  fmt.Println(err == nil)
}
```

## [L2.4](L2.4)

Что выведет программа?

Объяснить вывод программы.

```go
func main() {
  ch := make(chan int)
  go func() {
    for i := 0; i < 10; i++ {
    ch <- i
  }
}()
  for n := range ch {
    println(n)
  }
}
```

## [L2.5](L2.5)

Что выведет программа?

Объяснить вывод программы.

```go
package main

type customError struct {
  msg string
}

func (e *customError) Error() string {
  return e.msg
}

func test() *customError {
  // ... do something
  return nil
}

func main() {
  var err error
  err = test()
  if err != nil {
    println("error")
    return
  }
  println("ok")
}
```

## [L2.6](L2.6)

Что выведет программа?

Объяснить поведение срезов при передаче их в функцию.

```go
package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```

## [L2.7](L2.7)

Что выведет программа?

Объяснить работу конвейера с использованием select.

```go
package main

import (
  "fmt"
  "math/rand"
  "time"
)

func asChan(vs ...int) <-chan int {
  c := make(chan int)
  go func() {
    for _, v := range vs {
      c <- v
      time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
    }
  close(c)
}()
  return c
}

func merge(a, b <-chan int) <-chan int {
  c := make(chan int)
  go func() {
    for {
      select {
        case v, ok := <-a:
          if ok {
            c <- v
          } else {
            a = nil
          }
        case v, ok := <-b:
          if ok {
            c <- v
          } else {
            b = nil
          }
        }
        if a == nil && b == nil {
          close(c)
          return
        }
     }
   }()
  return c
}

  func main() {
    rand.Seed(time.Now().Unix())
    a := asChan(1, 3, 5, 7)
    b := asChan(2, 4, 6, 8)
    c := merge(a, b)
    for v := range c {
    fmt.Print(v)
  }
```

## [L2.8 Получение точного времени (NTP)](L2.8)

Создать программу, печатающую точное текущее время с использованием NTP-сервера.

- Реализовать проект как модуль Go.

- Использовать библиотеку [ntp](https://pkg.go.dev/github.com/beevik/ntp) для получения времени.

- Программа должна выводить текущее время, полученное через NTP (Network Time Protocol).

- Необходимо обрабатывать ошибки библиотеки: в случае ошибки вывести её текст в `STDERR` и вернуть ненулевой код выхода.

- Код должен проходить проверки (`vet` и `golint`), т.е. быть написан идиоматически корректно.

## [L2.9 Распаковка строки](L2.9)

Написать функцию Go, осуществляющую примитивную **распаковку строки**, содержащей повторяющиеся символы/руны.

Примеры работы функции:

```text
Вход: "a4bc2d5e"
Выход: "aaaabccddddde"
```

```text
Вход: "abcd"
Выход: "abcd" (нет цифр — ничего не меняется)
```

```text
Вход: "45"
Выход: "" (некорректная строка, т.к. в строке только цифры — функция должна вернуть ошибку)
```

```text
Вход: ""
Выход: "" (пустая строка -> пустая строка)
```

### Дополнительное задание

Поддерживать **escape-последовательности** вида \:

Вход: "qwe\4\5"
Выход: "qwe45" (4 и 5 не трактуются как числа, т.к. экранированы)

Вход: "qwe\45"
Выход: "qwe44444" (\4 экранирует 4, поэтому распаковывается только 5)

### Требования к реализации

Функция должна корректно обрабатывать ошибочные случаи (возвращать ошибку, например, через `error`), и проходить unit-тесты.

Код должен быть статически анализируем (`vet`, `golint`).

## [L2.10 Утилита sort](L2.10)

Реализовать упрощённый аналог UNIX-утилиты sort (сортировка строк).

Программа должна читать строки (из файла или STDIN) и выводить их отсортированными.

Обязательные флаги (как в GNU sort):

- `-k N` — сортировать по столбцу (колонке) №N (разделитель — табуляция по умолчанию).
Например, `sort -k 2` отсортирует строки по второму столбцу каждой строки.

- `-n` — сортировать по числовому значению (строки интерпретируются как числа).

- `-r` — сортировать в обратном порядке (reverse).

- `-u` — не выводить повторяющиеся строки (только уникальные).

Дополнительные флаги:

- `-M` — сортировать по названию месяца (Jan, Feb, ... Dec), т.е. распознавать специфический формат дат.

- `-b` — игнорировать хвостовые пробелы (trailing blanks).

- `-c` — проверить, отсортированы ли данные; если нет, вывести сообщение об этом.

- `-h` — сортировать по числовому значению с учётом суффиксов (например, К = килобайт, М = мегабайт — человекочитаемые размеры).

Программа должна корректно обрабатывать комбинации флагов (например, `-nr` — числовая сортировка в обратном порядке, и т.д.).

Необходимо предусмотреть эффективную обработку больших файлов.

Код должен проходить все тесты, а также проверки `go vet` и `golint` (понимание, что требуются надлежащие комментарии, имена и структура программы).

## [L2.11 Поиск анаграмм в словаре](L2.11)

Напишите функцию, которая находит все множества анаграмм по заданному словарю.

### Требования

- На вход подается срез строк (слов на русском языке в Unicode).

- На выходе: map-множество -> список, где ключом является первое встреченное слово множества, а значением — срез из всех слов, принадлежащих этому множеству анаграмм, отсортированных по возрастанию.

- Множества из одного слова не должны выводиться (т.е. если нет анаграмм, слово игнорируется).

- Все слова нужно привести к нижнему регистру.

Пример:

- Вход:

```bash
["пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"]
```

- Результат (ключи в примере могут быть в другом порядке):

```bash
"пятак": ["пятак", "пятка", "тяпка"]
"листок": ["листок", "слиток", "столик"]
```

- Слово `стол` отсутствует в результатах, так как не имеет анаграмм.

Для решения задачи потребуется умение работать со строками, сортировать
и использовать структуры данных (map).

Оценим эффективность: решение должно работать за линейно-логарифмическое время относительно количества слов (допустимо `n * m log m`, где `m` — средняя длина слова для сортировки букв).

## [L2.12 Утилита grep](L2.12)

Реализовать утилиту фильтрации текстового потока (аналог команды grep).

Программа должна читать входной поток (STDIN или файл) и выводить строки, соответствующие заданному шаблону (подстроке или регулярному выражению).

Необходимо поддерживать следующие флаги:

- `-A N` — после каждой найденной строки дополнительно вывести `N` строк после неё (контекст).

- `-B N` — вывести `N` строк до каждой найденной строки.

- `-C N` — вывести `N` строк контекста вокруг найденной строки (включает и до, и после; эквивалентно `-A N -B N`).

- `-c` — выводить только то количество строк, что совпадающих с шаблоном (т.е. вместо самих строк — число).

- `-i` — игнорировать регистр.

- `-v` — инвертировать фильтр: выводить строки, не содержащие шаблон.

- `-F` — воспринимать шаблон как фиксированную строку, а не регулярное выражение (т.е. выполнять точное совпадение подстроки).

- `-n` — выводить номер строки перед каждой найденной строкой.

Программа должна поддерживать сочетания флагов (например, `-C 2 -n -i` – 2 строки контекста, вывод номеров, без учета регистра и т.д.).

Результат работы должен максимально соответствовать поведению команды UNIX grep.

Обязательно учесть пограничные случаи (начало/конец файла для контекста, повторяющиеся совпадения и пр.).

Код должен быть чистым, отформатированным (gofmt), работать без ситуаций гонки и успешно проходить golint.

## [L2.13 Утилита cut](L2.13)

Реализовать утилиту, которая считывает входные данные (STDIN) и разбивает каждую строку по заданному разделителю, после чего выводит определённые поля (колонки).

Аналог команды cut с поддержкой флагов:

- `-f` "fields" — указание номеров полей (колонок), которые нужно вывести. Номера через запятую, можно диапазоны.
Например: «-f 1,3-5» — вывести 1-й и с 3-го по 5-й столбцы.

- `-d` "delimiter" — использовать другой разделитель (символ). По умолчанию разделитель — табуляция ('\t').

- `-s` – (separated) только строки, содержащие разделитель. Если флаг указан, то строки без разделителя игнорируются (не выводятся).

Программа должна корректно парсить аргументы, поддерживать различные комбинации (например, несколько отдельных полей и диапазонов), учитывать, что номера полей могут выходить за границы (в таком случае эти поля просто игнорируются).

Стоит обратить внимание на эффективность при обработке больших файлов. Все стандартные требования по качеству кода и тестам также применимы.

## [L2.14 Функция or (объединение done-каналов)](L2.14)

Реализовать функцию, которая будет объединять один или более каналов `done` (каналов сигнала завершения) в один. Возвращаемый канал должен закрываться, как только закроется любой из исходных каналов.

Сигнатура функции может быть такой:

```go
var or func(channels ...<-chan interface{}) <-chan interface{}
```

Пример использования функции:

```go
sig := func(after time.Duration) <-chan interface{} {
   c := make(chan interface{})
   go func() {
      defer close(c)
      time.Sleep(after)
   }()
   return c
}

start := time.Now()
<-or(
   sig(2*time.Hour),
   sig(5*time.Minute),
   sig(1*time.Second),
   sig(1*time.Hour),
   sig(1*time.Minute),
)
fmt.Printf("done after %v", time.Since(start))
```

В этом примере канал, возвращённый `or(...)`, закроется через ~1 секунду, потому что самый короткий канал `sig(1*time.Second)` закроется первым. Ваша реализация `or` должна уметь принимать на вход произвольное число каналов и завершаться при сигнале на любом из них.

Подсказка: используйте `select` в бесконечном цикле для чтения из всех каналов одновременно, либо рекурсивно объединяйте каналы попарно.

## [L2.15 Minishell: взаимодействие с ОС](L2.15)

Необходимо реализовать собственный простейший Unix shell.

Требования
Ваш интерпретатор командной строки должен поддерживать:

Встроенные команды:

– `cd <path>` – смена текущей директории.
– `pwd` – вывод текущей директории.
– `echo <args>` – вывод аргументов.
– `kill <pid>` – послать сигнал завершения процессу с заданным PID.
– `ps` – вывести список запущенных процессов.

Запуск внешних команд через exec (с помощью системных вызовов fork/exec либо стандартных функций os/exec).

Конвейеры (pipelines): возможность объединять команды через |, чтобы вывод одной команды направлять на ввод следующей (как в обычном shell).

Например: `ps | grep myprocess | wc -l`.

Обработку завершения: при нажатии Ctrl+D (EOF) шелл должен завершаться; Ctrl+C — прерывание текущей запущенной команды, но без закрытия самой shell.

Дополнительно: реализовать парсинг && и || (условное выполнение команд), подстановку переменных окружения $VAR, поддержку редиректов >/< для вывода в файл и чтения из файла.

Основной упор необходимо делать на реализацию базового функционала (exec, builtins, pipelines). Проверять надо как интерактивно, так и скриптом. Код должен работать без ситуаций гонки, корректно освобождать ресурсы.

Совет: используйте пакеты os/exec, bufio (для ввода), strings.Fields (для разбиения командной строки на аргументы) и системные вызовы через syscall, если потребуется.

## [L2.16 Утилита wget (упрощенная)](L2.16)

Реализовать утилиту загрузки веб-страниц **вместе со всем вложенным контентом** (ресурсы, ссылки), аналогичную `wget -m` (мирроринг сайта).

Требования:

- Программа должна принимать URL и, возможно, глубину рекурсии (количество уровней ссылок, которые нужно скачать).

- Должна уметь скачивать HTML-страницы, сохранять их локально, а также рекурсивно скачивать ресурсы: CSS, JS, изображения и т.д., а так же страницы, на которые есть ссылки (в рамках того же домена).

- На выходе должен получиться локальный каталог, содержащий копию сайта (или его части), чтобы страницу можно было открыть офлайн.

- Необходимо обрабатывать различные нюансы: относительные и абсолютные ссылки, дублирование (не скачивать один и тот же ресурс несколько раз), корректно формировать локальные пути для сохранения, избегать зацикливания по ссылкам.

- Опционально: поддержать параллельное скачивание (например, ограничить до N одновременных загрузок), управлять robots.txt и пр.

Эта задача проверяет навыки сетевого программирования (HTTP-запросы), работы с файлами и строками, а также проектирования (нужно спланировать структуру, как хранить информацию о посещенных URL, как сохранять файлы и менять ссылки внутри HTML на локальные и т.д.).

Постарайтесь разбить программу на функции и пакеты: например, парсер HTML, загрузчик и т.п.

Обязательно учтите обработку ошибок (сетевых, файловых) и время выполнения (можно добавить таймауты на запросы).

## [L2.17 Утилита telnet (примитивный telnet-клиент)](L2.17)

Реализовать простой telnet-клиент с возможностью соединяться к TCP-серверу и взаимодействовать с ним:

- Программа должна принимать параметры: хост, порт и опционально таймаут соединения (через флаг `--timeout`, по умолчанию 10 секунд).

- После запуска, telnet-клиент устанавливает TCP-соединение с указанным `host:port`.

- Все, что пользователь вводит в STDIN, должно отправляться в сокет; все, что приходит из сокета — печататься в STDOUT.

- При нажатии комбинации клавиш `Ctrl+D` клиент должен закрыть соединение и завершиться. Если сервер закрыл соединение, клиент тоже завершается.

- В случае, если попытка подключения не удалась (например, сервер недоступен) — программа завершается через заданный `timeout` с соответствующим сообщением об ошибке.

Проверить программу можно, например, подключившись к какому-нибудь публичному echo-серверу или SMTP (порт: 25) и вручную отправляя команды.

Обратите внимание на обработку буферов: желательно запускать чтение/запись в отдельных горутинах (для конкурентного ввода/вывода). Код должен быть без гонок. Реализация данной утилиты подразумевает использование пакета `net` (тип `net.Conn`), и возможно `bufio` для удобства чтения/записи.
