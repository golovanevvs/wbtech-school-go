# L2

## [L2.1](L2.1)

Что выведет программа?

Объясните вывод программы.

```go
package main

import "fmt"

func main() {
  a := [5]int{76, 77, 78, 79, 80}
  var b []int = a[1:4]
  fmt.Println(b)
}
```

## [L2.2](L2.2)

Что выведет программа?

Объяснить порядок выполнения defer функций и итоговый вывод.

```go
package main

import "fmt"

func test() (x int) {
  defer func() {
    x++
  }()
  x = 1
  return
}

func anotherTest() int {
  var x int
  defer func() {
    x++
  }()
  x = 1
  return x
}

func main() {
  fmt.Println(test())
  fmt.Println(anotherTest())
}
```

## [L2.3](L2.3)

Что выведет программа?

Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
  "fmt"
  "os"
)

func Foo() error {
  var err *os.PathError = nil
  return err
}

func main() {
  err := Foo()
  fmt.Println(err)
  fmt.Println(err == nil)
}
```

## [L2.4](L2.4)

Что выведет программа?

Объяснить вывод программы.

```go
func main() {
  ch := make(chan int)
  go func() {
    for i := 0; i < 10; i++ {
    ch <- i
  }
}()
  for n := range ch {
    println(n)
  }
}
```

## [L2.5](L2.5)

Что выведет программа?

Объяснить вывод программы.

```go
package main

type customError struct {
  msg string
}

func (e *customError) Error() string {
  return e.msg
}

func test() *customError {
  // ... do something
  return nil
}

func main() {
  var err error
  err = test()
  if err != nil {
    println("error")
    return
  }
  println("ok")
}
```

## [L2.6](L2.6)

Что выведет программа?

Объяснить поведение срезов при передаче их в функцию.

```go
package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```

## [L2.7](L2.7)

Что выведет программа?

Объяснить работу конвейера с использованием select.

```go
package main

import (
  "fmt"
  "math/rand"
  "time"
)

func asChan(vs ...int) <-chan int {
  c := make(chan int)
  go func() {
    for _, v := range vs {
      c <- v
      time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
    }
  close(c)
}()
  return c
}

func merge(a, b <-chan int) <-chan int {
  c := make(chan int)
  go func() {
    for {
      select {
        case v, ok := <-a:
          if ok {
            c <- v
          } else {
            a = nil
          }
        case v, ok := <-b:
          if ok {
            c <- v
          } else {
            b = nil
          }
        }
        if a == nil && b == nil {
          close(c)
          return
        }
     }
   }()
  return c
}

  func main() {
    rand.Seed(time.Now().Unix())
    a := asChan(1, 3, 5, 7)
    b := asChan(2, 4, 6, 8)
    c := merge(a, b)
    for v := range c {
    fmt.Print(v)
  }
```

## [L2.8 Получение точного времени (NTP)](L2.8)

Создать программу, печатающую точное текущее время с использованием NTP-сервера.

- Реализовать проект как модуль Go.

- Использовать библиотеку [ntp](https://pkg.go.dev/github.com/beevik/ntp) для получения времени.

- Программа должна выводить текущее время, полученное через NTP (Network Time Protocol).

- Необходимо обрабатывать ошибки библиотеки: в случае ошибки вывести её текст в `STDERR` и вернуть ненулевой код выхода.

- Код должен проходить проверки (`vet` и `golint`), т.е. быть написан идиоматически корректно.

## [L2.9 Распаковка строки](L2.9)

Написать функцию Go, осуществляющую примитивную **распаковку строки**, содержащей повторяющиеся символы/руны.

Примеры работы функции:

```text
Вход: "a4bc2d5e"
Выход: "aaaabccddddde"
```

```text
Вход: "abcd"
Выход: "abcd" (нет цифр — ничего не меняется)
```

```text
Вход: "45"
Выход: "" (некорректная строка, т.к. в строке только цифры — функция должна вернуть ошибку)
```

```text
Вход: ""
Выход: "" (пустая строка -> пустая строка)
```

### Дополнительное задание

Поддерживать **escape-последовательности** вида \:

Вход: "qwe\4\5"
Выход: "qwe45" (4 и 5 не трактуются как числа, т.к. экранированы)

Вход: "qwe\45"
Выход: "qwe44444" (\4 экранирует 4, поэтому распаковывается только 5)

### Требования к реализации

Функция должна корректно обрабатывать ошибочные случаи (возвращать ошибку, например, через `error`), и проходить unit-тесты.

Код должен быть статически анализируем (`vet`, `golint`).

## [L2.10 Утилита sort](L2.10)

Реализовать упрощённый аналог UNIX-утилиты sort (сортировка строк).

Программа должна читать строки (из файла или STDIN) и выводить их отсортированными.

Обязательные флаги (как в GNU sort):

- `-k N` — сортировать по столбцу (колонке) №N (разделитель — табуляция по умолчанию).
Например, `sort -k 2` отсортирует строки по второму столбцу каждой строки.

- `-n` — сортировать по числовому значению (строки интерпретируются как числа).

- `-r` — сортировать в обратном порядке (reverse).

- `-u` — не выводить повторяющиеся строки (только уникальные).

Дополнительные флаги:

- `-M` — сортировать по названию месяца (Jan, Feb, ... Dec), т.е. распознавать специфический формат дат.

- `-b` — игнорировать хвостовые пробелы (trailing blanks).

- `-c` — проверить, отсортированы ли данные; если нет, вывести сообщение об этом.

- `-h` — сортировать по числовому значению с учётом суффиксов (например, К = килобайт, М = мегабайт — человекочитаемые размеры).

Программа должна корректно обрабатывать комбинации флагов (например, `-nr` — числовая сортировка в обратном порядке, и т.д.).

Необходимо предусмотреть эффективную обработку больших файлов.

Код должен проходить все тесты, а также проверки `go vet` и `golint` (понимание, что требуются надлежащие комментарии, имена и структура программы).

## [L2.11 Поиск анаграмм в словаре](L2.11)

Напишите функцию, которая находит все множества анаграмм по заданному словарю.

### Требования

- На вход подается срез строк (слов на русском языке в Unicode).

- На выходе: map-множество -> список, где ключом является первое встреченное слово множества, а значением — срез из всех слов, принадлежащих этому множеству анаграмм, отсортированных по возрастанию.

- Множества из одного слова не должны выводиться (т.е. если нет анаграмм, слово игнорируется).

- Все слова нужно привести к нижнему регистру.

Пример:

- Вход:

```bash
["пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"]
```

- Результат (ключи в примере могут быть в другом порядке):

```bash
"пятак": ["пятак", "пятка", "тяпка"]
"листок": ["листок", "слиток", "столик"]
```

- Слово `стол` отсутствует в результатах, так как не имеет анаграмм.

Для решения задачи потребуется умение работать со строками, сортировать
и использовать структуры данных (map).

Оценим эффективность: решение должно работать за линейно-логарифмическое время относительно количества слов (допустимо `n * m log m`, где `m` — средняя длина слова для сортировки букв).
